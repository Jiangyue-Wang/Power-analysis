library(tidyverse)
library(fixest)
library(broom)
# Make a tibble (or data.frame) to contain our data
tib <- tibble(
  # Start by creating the variables that don't depend on anything else
  # the 1000 is how many observations we're going to have. THe 0 and 1 are the start and end of the uniform distribution
  X = runif(1000, 0, 1)
) %>%
  # Then mutate in any variables that depend on earlier variables
  # Don't forget to add additional noise!
  # The *true effect* of X on Y is .2
  mutate(Y = .2*X + rnorm(1000, mean = 0, sd = 3))
head(tib)

model <- feols(Y ~ X, data = tib, se = 'hetero')
tidy(model)
tidy(model)$p.value[2]
sig <- tidy(model)$p.value[2] <= .05
sig


coef_results <- c()
sig_results <- c()

for (i in 1:2000) {
  # Have to re-create the data EVERY TIME or it will just be the same data over and over
  tib <- tibble(
    X = runif(1000, 0, 1)
  ) %>%
    mutate(Y = .2*X + rnorm(1000, mean = 0, sd = 3))
  
  # Run the analysis
  model <- feols(Y ~ X, data = tib, se = 'hetero')
  
  # Get the results
  coef_results[i] <- coef(model)[2]
  sig_results[i] <- tidy(model)$p.value[2] <= .05
}
mean(sig_results)

ggplot(mapping = aes(coef_results)) + 
  geom_density()


my_power_function <- function(effect, sample_size) {
  sig_results <- c()
  
  for (i in 1:500) {
    # Have to re-create the data EVERY TIME or it will just be the same data over and over
    tib <- tibble(
      X = runif(sample_size, 0, 1)
    ) %>%
      mutate(Y = effect*X + rnorm(sample_size, mean = 0, sd = 3))
    
    # Run the analysis
    model <- feols(Y ~ X, data = tib, se = 'hetero')
    
    # Get the results
    sig_results[i] <- tidy(model)$p.value[2] <= .05
  }
  
  sig_results %>%
    mean() %>%
    return()
}


my_power_function(.2, 1000)


power_levels <- c()

effects_to_try <- c(.4, .8, 1.2, 1.6, 2)

for (i in 1:5) {
  power_levels[i] <- my_power_function(effects_to_try[i], 1000)
}

# Where do we cross 80%?
power_results <- tibble(effect = effects_to_try,
                        power = power_levels)
power_results


ggplot(power_results, 
       aes(x = effect, y = power)) +
  geom_line(color = 'red', size = 1.5) + 
  # add a horizontal line at 90%
  geom_hline(aes(yintercept = .8), linetype = 'dashed') + 
  # Prettify!
  theme_minimal() + 
  scale_y_continuous(labels = scales::percent) + 
  labs(x = 'Linear Effect Size', y = 'Power')



tib <- tibble(
  # Let's make the confounder uniformly distributed
  # 0 and 1 start/end points are default
  W = runif(1000),
  # We can assign groups from 1 to 10, a categorical variable, using sample()
  # if we don't specify prob it defaults to equal probabilities
  group = sample(1:10, 1000, replace = TRUE)
)

# Now for the group-level assignment. First let's get group-average W since that will affect assignment
groupdata <- tib %>%
  group_by(group) %>%
  summarize(mean_W = mean(W)) %>%
  # Your group is treated with a probability of .5 + mean_W/10, which we can get
  # using runif() (X > runif() occurs with a probability of X)
  # notice for the sample size here we use nrow(.), which refers to the number of 
  # rows in the data we're working with, in case by random chance not all 10 groups got assigned
  mutate(treated = .5 + mean_W/10 >= runif(nrow(.)))

# Now let's bring the group-level treatment back into the data
tib <- tib %>%
  left_join(groupdata) %>%
  # and make an outcome based on treatment and W and group
  # True effect of treatment 1
  mutate(Y = 1*treated + W + group/10 + rnorm(1000))

m <- lm(Y~treated + W, data = tib)

sig <- tidy(m)$p.value[2] <= .01


my_power_function <- function(effect, sample_size) {
  sig_results <- c()
  
  for (i in 1:500) {
    tib <- tibble(
      # Let's make the confounder uniformly distributed
      # 0 and 1 start/end points are default
      W = runif(sample_size),
      # We can assign groups from 1 to 10, a categorical variable, using sample()
      # if we don't specify prob it defaults to equal probabilities
      group = sample(1:10, sample_size, replace = TRUE)
    )
    
    # Now for the group-level assignment. First let's get group-average W since that will affect assignment
    groupdata <- tib %>%
      group_by(group) %>%
      summarize(mean_W = mean(W)) %>%
      # Your group is treated with a probability of .5 + mean_W/10, which we can get
      # using runif() (X > runif() occurs with a probability of X)
      # notice for the sample size here we use nrow(.), which refers to the number of 
      # rows in the data we're working with, in case by random chance not all 10 groups got assigned
      mutate(treated = .5 + mean_W/10 >= runif(nrow(.)))
    
    # Now let's bring the group-level treatment back into the data
    tib <- tib %>%
      left_join(groupdata) %>%
      # and make an outcome based on treatment and W and group
      # True effect of treatment 1
      mutate(Y = effect*treated + W + group/10 + rnorm(sample_size))
    
    m <- lm(Y~treated + W, data = tib)
    
    sig_results[i] <- tidy(m)$p.value[2] <= .01
  }
  
  sig_results %>%
    # Tack a na.rm = TRUE on here in case one of the regressions fails so it doesn't taint the whole thing!)
    mean(na.rm = TRUE) %>%
    return()
}

power_levels <- c()

sample_sizes_to_try <- c(50, 100, 200, 300, 400, 500)

for (i in 1:6) {
  power_levels[i] <- my_power_function(1, sample_sizes_to_try[i])
}

# Where do we cross 80%?
power_results <- tibble(sample = sample_sizes_to_try,
                        power = power_levels)
power_results


ggplot(power_results, 
       aes(x = sample, y = power)) +
  geom_line(color = 'red', size = 1.5) + 
  # add a horizontal line at 90%
  geom_hline(aes(yintercept = .9), linetype = 'dashed') + 
  # Prettify!
  theme_minimal() + 
  scale_y_continuous(labels = scales::percent) + 
  labs(x = 'Sample Size', y = 'Power')

save.image("~/Desktop/phD/生态、保护科学研究设计/Assignments/Power-practice.RData")
load("~/Desktop/Desktop - 江月王的MacBook Pro/phD/Research-Design/Assignments/Power-practice.RData")
